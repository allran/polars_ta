import talib as _talib
from talib import abstract as _abstract


def _codegen_func_v1(name, input_names, parameters, output_names):
    tpl1 = """
def {name}({aa}) -> pl.Expr:
    return {bb}.ta.{name}({cc})

"""
    tpl2 = """
def {name}({aa}) -> pl.Expr:
    return pl.struct({bb}).ta.{name}({cc})

"""

    extra_args = {'skip_nan': False, 'output_idx': None, 'schema': tuple(output_names), 'schema_format': "'{}'"}
    a1 = [f'{name}: pl.Expr' for name in input_names]
    a2 = [f'{k}: {type(v).__name__} = {v}' for k, v in parameters.items()]
    a3 = [f'{k}={v}' for k, v in extra_args.items()]
    aa = ', '.join(a1 + a2 + a3)

    bb = ', '.join(input_names)

    c1 = [f'{k}' for k, v in parameters.items()]
    c2 = [f'{k}={k}' for k, v in extra_args.items()]
    cc = ', '.join(c1 + c2)

    if len(input_names) > 1:
        return tpl2.format(name=name, aa=aa, bb=bb, cc=cc)
    else:
        return tpl1.format(name=name, aa=aa, bb=bb, cc=cc)


def _codegen_func_v2(name, input_names, parameters, output_names):
    tpl11 = """
def {name}({aa}) -> pl.Expr:
    return {bb}.map_batches(lambda x: func_wrap_11(talib.{name}, x, {cc}))

"""
    tpl12 = """
def {name}({aa}) -> pl.Expr:
    return {bb}.map_batches(lambda x: func_wrap_mn(talib.{name}, x, {cc}))

"""
    tpl2X = """
def {name}({aa}) -> pl.Expr:
    return pl.struct({bb}).map_batches(lambda x: func_wrap_mn(talib.{name}, x, {cc}))

"""

    extra_args = {'skip_nan': False, 'output_idx': None, 'schema': tuple(output_names), 'schema_format': "'{}'"}
    a1 = [f'{name}: pl.Expr' for name in input_names]
    a2 = [f'{k}: {type(v).__name__} = {v}' for k, v in parameters.items()]
    a3 = [f'{k}={v}' for k, v in extra_args.items()]
    aa = ', '.join(a1 + a2 + a3)

    bb = ', '.join(input_names)

    if len(parameters) > 0:
        c1 = [f'{k}' for k, v in parameters.items()]
    else:
        c1 = []

    c2 = [f'{k}={k}' for k, v in extra_args.items()]
    cc = ', '.join(c1 + c2)

    if name == 'ATR':
        debug = 1

    if len(input_names) == 1 and len(output_names) == 1:
        return tpl11.format(name=name, aa=aa, bb=bb, cc=cc)
    elif len(input_names) == 1 and len(output_names) > 1:
        return tpl12.format(name=name, aa=aa, bb=bb, cc=cc)
    else:
        return tpl2X.format(name=name, aa=aa, bb=bb, cc=cc)


def codegen():
    head_v1 = """# generated by codegen_talib.py
import polars as pl

from polars_ta.utils.helper import TaLibHelper

_ = TaLibHelper

"""
    head_v2 = """# generated by codegen_talib.py
import polars as pl
import talib

from polars_ta.utils.helper import TaLibHelper, func_wrap_11, func_wrap_mn

_ = TaLibHelper

"""

    context = [head_v2]
    for i, func_name in enumerate(_talib.get_functions()):
        """talib遍历"""
        info = _abstract.Function(func_name).info

        name = info['name']
        input_names = []
        for in_names in info['input_names'].values():
            if isinstance(in_names, (list, tuple)):
                input_names.extend(list(in_names))
            else:
                input_names.append(in_names)
        parameters = info['parameters']
        output_names = info['output_names']
        # 两种生成模式，v2版直接一些，所以要快一点点
        # txt = _codegen_func_v1(name, input_names, parameters, output_names)
        txt = _codegen_func_v2(name, input_names, parameters, output_names)
        context.append(txt)

    return context


def save(context):
    import polars_ta.talib
    file = polars_ta.talib.__file__
    print('save to', file)
    with open(file, 'w', encoding='utf-8') as f:
        f.writelines(context)


if __name__ == '__main__':
    context = codegen()
    save(context)
