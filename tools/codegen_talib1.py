"""
Parse talib functions for polars Expressions
本脚本主要功能是将talib封装成更适合表达式的版本
"""
import talib as _talib
from talib import abstract as _abstract

from tools.prefix import save


def _codegen_func_v1(name, input_names, parameters, output_names):
    tpl1 = """
def {name}({aa}) -> Expr:
    return {bb}.ta.{name}({cc})
"""
    tpl2 = """
def {name}({aa}) -> Expr:
    return _struct({bb}).ta.{name}({cc})
"""

    extra_args = {'skip_nan': False, 'output_idx': None, 'schema': tuple(output_names), 'schema_format': "'{}'", 'nan_to_null': False}
    a1 = [f'{name}: Expr' for name in input_names]
    a2 = [f'{k}: {type(v).__name__} = {v}' for k, v in parameters.items()]
    a3 = [f'{k}={v}' for k, v in extra_args.items()]
    aa = ', '.join(a1 + a2 + a3)

    bb = ', '.join(input_names)

    c1 = [f'{k}' for k, v in parameters.items()]
    c2 = [f'{k}={k}' for k, v in extra_args.items()]
    cc = ', '.join(c1 + c2)

    if len(input_names) > 1:
        return tpl2.format(name=name, aa=aa, bb=bb, cc=cc)
    else:
        return tpl1.format(name=name, aa=aa, bb=bb, cc=cc)


def _codegen_func_v2(name, input_names, parameters, output_names):
    tpl11 = """
def {name}({aa}) -> Expr:
    return {bb}.map_batches(lambda x: _func_wrap_11(_ta.{name}, x, {cc}))
"""
    tpl12 = """
def {name}({aa}) -> Expr:
    return {bb}.map_batches(lambda x: _func_wrap_mn(_ta.{name}, x, {cc}))
"""
    tpl2X = """
def {name}({aa}) -> Expr:
    return _struct({bb}).map_batches(lambda x: _func_wrap_mn(_ta.{name}, x, {cc}))
"""

    extra_args = {'skip_nan': False, 'output_idx': None, 'schema': tuple(output_names), 'schema_format': "'{}'", 'nan_to_null': False}
    a1 = [f'{name}: Expr' for name in input_names]
    a2 = [f'{k}: {type(v).__name__} = {v}' for k, v in parameters.items()]
    a3 = [f'{k}={v}' for k, v in extra_args.items()]
    aa = ', '.join(a1 + a2 + a3)

    bb = ', '.join(input_names)

    if len(parameters) > 0:
        c1 = [f'{k}' for k, v in parameters.items()]
    else:
        c1 = []

    c2 = [f'{k}={k}' for k, v in extra_args.items()]
    cc = ', '.join(c1 + c2)

    if len(input_names) == 1 and len(output_names) == 1:
        return tpl11.format(name=name, aa=aa, bb=bb, cc=cc)
    elif len(input_names) == 1 and len(output_names) > 1:
        return tpl12.format(name=name, aa=aa, bb=bb, cc=cc)
    else:
        return tpl2X.format(name=name, aa=aa, bb=bb, cc=cc)


def codegen():
    head_v1 = """# generated by codegen_talib1.py
from polars import Expr
from polars import struct as _struct

from polars_ta.utils.helper import TaLibHelper # noqa
"""
    head_v2 = """# generated by codegen_talib1.py
import talib as _ta
from polars import Expr
from polars import struct as _struct

from polars_ta.utils.helper import TaLibHelper # noqa
from polars_ta.utils.helper import func_wrap_11 as _func_wrap_11
from polars_ta.utils.helper import func_wrap_mn as _func_wrap_mn
"""

    txts = [head_v2]
    for i, func_name in enumerate(_talib.get_functions()):
        """talib遍历"""
        info = _abstract.Function(func_name).info

        name = info['name']
        input_names = []
        for in_names in info['input_names'].values():
            if isinstance(in_names, (list, tuple)):
                input_names.extend(list(in_names))
            else:
                input_names.append(in_names)
        parameters = info['parameters']
        output_names = info['output_names']
        # two modes, v2 is faster
        # 两种生成模式，v2版直接一些，所以要快一点点
        # txt = _codegen_func_v1(name, input_names, parameters, output_names)
        txt = _codegen_func_v2(name, input_names, parameters, output_names)
        txts.append(txt)

    return txts


if __name__ == '__main__':
    txts = codegen()
    save(txts, module='polars_ta.talib', write=True)
